#!/bin/bash

# N8N AI Starter Kit - Health Check Script
# Проверяет состояние всех сервисов и отправляет метрики

set -euo pipefail

# Конфигурация
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

# Цвета для вывода
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Функции логирования
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Метрики
METRICS_FILE="/tmp/n8n_health_metrics.prom"

# Функция записи метрик
write_metric() {
    local metric_name="$1"
    local metric_value="$2"
    local labels="$3"
    local help="$4"
    
    echo "# HELP $metric_name $help" >> "$METRICS_FILE"
    echo "# TYPE $metric_name gauge" >> "$METRICS_FILE"
    if [[ -n "$labels" ]]; then
        echo "${metric_name}{${labels}} $metric_value" >> "$METRICS_FILE"
    else
        echo "$metric_name $metric_value" >> "$METRICS_FILE"
    fi
}

# Инициализация файла метрик
init_metrics() {
    cat > "$METRICS_FILE" << 'EOF'
# N8N AI Starter Kit Health Metrics
# Generated by health-check.sh
EOF
}

# Проверка HTTP сервиса
check_http_service() {
    local service_name="$1"
    local url="$2"
    local expected_status="${3:-200}"
    
    log_info "Checking $service_name at $url"
    
    local response_code
    local response_time
    
    # Измеряем время ответа
    local start_time=$(date +%s%N)
    response_code=$(curl -s -o /dev/null -w "%{http_code}" "$url" --max-time 10 || echo "000")
    local end_time=$(date +%s%N)
    response_time=$(( (end_time - start_time) / 1000000 )) # в миллисекундах
    
    # Записываем метрики
    local status=0
    if [[ "$response_code" == "$expected_status" ]]; then
        status=1
        log_success "$service_name is healthy (HTTP $response_code, ${response_time}ms)"
    else
        log_error "$service_name is unhealthy (HTTP $response_code, ${response_time}ms)"
    fi
    
    write_metric "service_health_status" "$status" "service=\"$service_name\"" "Service health status (1=healthy, 0=unhealthy)"
    write_metric "service_response_time_ms" "$response_time" "service=\"$service_name\"" "Service response time in milliseconds"
    write_metric "service_http_status_code" "$response_code" "service=\"$service_name\"" "Last HTTP status code"
    
    return $((1 - status))
}

# Проверка Docker контейнера
check_docker_container() {
    local container_name="$1"
    local service_name="${2:-$container_name}"
    
    log_info "Checking Docker container: $container_name"
    
    local status=0
    local cpu_percent=0
    local memory_usage=0
    local memory_limit=0
    
    # Проверяем статус контейнера
    if docker ps --filter "name=$container_name" --filter "status=running" | grep -q "$container_name"; then
        status=1
        log_success "Container $container_name is running"
        
        # Получаем статистику контейнера
        local stats=$(docker stats "$container_name" --no-stream --format "table {{.CPUPerc}}\t{{.MemUsage}}" | tail -n 1)
        if [[ -n "$stats" ]]; then
            cpu_percent=$(echo "$stats" | awk '{print $1}' | sed 's/%//')
            local mem_info=$(echo "$stats" | awk '{print $2}')
            memory_usage=$(echo "$mem_info" | cut -d'/' -f1 | sed 's/[^0-9.]//g')
            memory_limit=$(echo "$mem_info" | cut -d'/' -f2 | sed 's/[^0-9.]//g')
        fi
    else
        log_error "Container $container_name is not running"
    fi
    
    # Записываем метрики
    write_metric "container_status" "$status" "container=\"$container_name\",service=\"$service_name\"" "Container status (1=running, 0=not running)"
    write_metric "container_cpu_percent" "$cpu_percent" "container=\"$container_name\",service=\"$service_name\"" "Container CPU usage percentage"
    write_metric "container_memory_usage_mb" "$memory_usage" "container=\"$container_name\",service=\"$service_name\"" "Container memory usage in MB"
    write_metric "container_memory_limit_mb" "$memory_limit" "container=\"$container_name\",service=\"$service_name\"" "Container memory limit in MB"
    
    return $((1 - status))
}

# Проверка дискового пространства
check_disk_space() {
    log_info "Checking disk space"
    
    local usage_percent=$(df "$PROJECT_ROOT" | tail -1 | awk '{print $5}' | sed 's/%//')
    local available_gb=$(df -h "$PROJECT_ROOT" | tail -1 | awk '{print $4}' | sed 's/G//')
    
    write_metric "disk_usage_percent" "$usage_percent" "path=\"$PROJECT_ROOT\"" "Disk usage percentage"
    write_metric "disk_available_gb" "$available_gb" "path=\"$PROJECT_ROOT\"" "Available disk space in GB"
    
    if [[ $usage_percent -lt 80 ]]; then
        log_success "Disk space is OK ($usage_percent% used, ${available_gb}GB available)"
    elif [[ $usage_percent -lt 90 ]]; then
        log_warning "Disk space is getting low ($usage_percent% used, ${available_gb}GB available)"
    else
        log_error "Disk space is critically low ($usage_percent% used, ${available_gb}GB available)"
        return 1
    fi
    
    return 0
}

# Проверка Docker сервисов
check_docker_services() {
    log_info "Checking Docker services status"
    
    local services=(
        "n8n-ai-prometheus:prometheus"
        "n8n-ai-grafana:grafana"
        "n8n-ai-alertmanager:alertmanager"
        "n8n-ai-node-exporter:node-exporter"
        "n8n-ai-cadvisor:cadvisor"
        "n8n-ai-n8n-exporter:n8n-exporter"
    )
    
    local failed_services=0
    
    for service_info in "${services[@]}"; do
        local container_name=$(echo "$service_info" | cut -d':' -f1)
        local service_name=$(echo "$service_info" | cut -d':' -f2)
        
        if ! check_docker_container "$container_name" "$service_name"; then
            ((failed_services++))
        fi
    done
    
    write_metric "failed_services_count" "$failed_services" "" "Number of failed services"
    
    return $failed_services
}

# Проверка HTTP сервисов
check_http_services() {
    log_info "Checking HTTP services"
    
    local services=(
        "prometheus:http://localhost:9090/-/healthy"
        "grafana:http://localhost:3000/api/health"
        "alertmanager:http://localhost:9093/-/healthy"
        "node-exporter:http://localhost:9100/metrics"
        "cadvisor:http://localhost:8080/healthz"
    )
    
    local failed_http_services=0
    
    for service_info in "${services[@]}"; do
        local service_name=$(echo "$service_info" | cut -d':' -f1)
        local url=$(echo "$service_info" | cut -d':' -f2,3)
        
        if ! check_http_service "$service_name" "$url"; then
            ((failed_http_services++))
        fi
    done
    
    write_metric "failed_http_services_count" "$failed_http_services" "" "Number of failed HTTP services"
    
    return $failed_http_services
}

# Проверка основных сервисов N8N
check_n8n_services() {
    log_info "Checking N8N ecosystem services"
    
    local n8n_services=(
        "n8n:http://localhost:5678/healthz"
        "qdrant:http://localhost:6333/health"
        "postgres:localhost:5432"
    )
    
    local failed_n8n_services=0
    
    # N8N
    if ! check_http_service "n8n" "http://localhost:5678/healthz"; then
        ((failed_n8n_services++))
    fi
    
    # Qdrant
    if ! check_http_service "qdrant" "http://localhost:6333/health"; then
        ((failed_n8n_services++))
    fi
    
    # PostgreSQL (проверяем через nc или telnet)
    if command -v nc &> /dev/null; then
        if nc -z localhost 5432; then
            log_success "PostgreSQL is reachable"
            write_metric "service_health_status" "1" "service=\"postgres\"" "Service health status"
        else
            log_error "PostgreSQL is not reachable"
            write_metric "service_health_status" "0" "service=\"postgres\"" "Service health status"
            ((failed_n8n_services++))
        fi
    fi
    
    write_metric "failed_n8n_services_count" "$failed_n8n_services" "" "Number of failed N8N ecosystem services"
    
    return $failed_n8n_services
}

# Генерация итогового отчета
generate_summary() {
    local total_checks="$1"
    local failed_checks="$2"
    local success_rate=$((100 * (total_checks - failed_checks) / total_checks))
    
    write_metric "health_check_success_rate_percent" "$success_rate" "" "Overall health check success rate"
    write_metric "health_check_total_checks" "$total_checks" "" "Total number of health checks performed"
    write_metric "health_check_failed_checks" "$failed_checks" "" "Number of failed health checks"
    write_metric "health_check_timestamp" "$(date +%s)" "" "Timestamp of last health check"
    
    echo ""
    if [[ $failed_checks -eq 0 ]]; then
        log_success "=== ALL SYSTEMS HEALTHY ==="
        log_success "Success rate: 100% ($total_checks/$total_checks checks passed)"
    elif [[ $success_rate -ge 80 ]]; then
        log_warning "=== SYSTEM STATUS: WARNING ==="
        log_warning "Success rate: $success_rate% ($((total_checks - failed_checks))/$total_checks checks passed)"
        log_warning "Failed checks: $failed_checks"
    else
        log_error "=== SYSTEM STATUS: CRITICAL ==="
        log_error "Success rate: $success_rate% ($((total_checks - failed_checks))/$total_checks checks passed)"
        log_error "Failed checks: $failed_checks"
    fi
    
    log_info "Health metrics written to: $METRICS_FILE"
}

# Отправка метрик в Prometheus (если настроено)
push_metrics() {
    local pushgateway_url="${PUSHGATEWAY_URL:-}"
    
    if [[ -n "$pushgateway_url" ]]; then
        log_info "Pushing metrics to Pushgateway: $pushgateway_url"
        
        if curl -X POST --data-binary @"$METRICS_FILE" \
               "$pushgateway_url/metrics/job/n8n_health_check/instance/$(hostname)"; then
            log_success "Metrics pushed successfully"
        else
            log_error "Failed to push metrics"
        fi
    fi
}

# Основная функция
main() {
    local mode="${1:-full}"
    
    echo "=== N8N AI Starter Kit Health Check ==="
    echo "Mode: $mode"
    echo "Time: $(date)"
    echo ""
    
    init_metrics
    
    local total_checks=0
    local failed_checks=0
    
    case "$mode" in
        "docker")
            if ! check_docker_services; then
                failed_checks=$?
            fi
            total_checks=6
            ;;
        "http")
            if ! check_http_services; then
                failed_checks=$?
            fi
            total_checks=5
            ;;
        "n8n")
            if ! check_n8n_services; then
                failed_checks=$?
            fi
            total_checks=3
            ;;
        "full"|*)
            # Полная проверка
            check_disk_space || ((failed_checks++))
            total_checks=$((total_checks + 1))
            
            local docker_failed=0
            check_docker_services || docker_failed=$?
            failed_checks=$((failed_checks + docker_failed))
            total_checks=$((total_checks + 6))
            
            local http_failed=0
            check_http_services || http_failed=$?
            failed_checks=$((failed_checks + http_failed))
            total_checks=$((total_checks + 5))
            
            local n8n_failed=0
            check_n8n_services || n8n_failed=$?
            failed_checks=$((failed_checks + n8n_failed))
            total_checks=$((total_checks + 3))
            ;;
    esac
    
    generate_summary "$total_checks" "$failed_checks"
    push_metrics
    
    # Возвращаем код ошибки если есть проблемы
    [[ $failed_checks -eq 0 ]]
}

# Запуск
main "$@"
